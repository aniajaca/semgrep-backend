const express = require('express');
const multer = require('multer');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

const app = express();
const PORT = process.env.PORT || 3000;

// Custom CORS middleware to avoid path-to-regexp issues
const customCors = (req, res, next) => {
  const allowedOrigins = [
    process.env.ALLOWED_ORIGIN,
    'http://localhost:3000',
    'http://localhost:5173',
    'https://preview--neperia-code-guardian.lovable.app'
  ].filter(Boolean); // Remove any undefined values

  const origin = req.headers.origin;
  
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  
  // Handle preflight requests
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  next();
};

// Apply CORS middleware
app.use(customCors);

// Body parsing middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(os.tmpdir(), 'uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    // Keep original filename with timestamp to avoid conflicts
    const timestamp = Date.now();
    const originalName = file.originalname || 'uploaded_file';
    cb(null, `${timestamp}-${originalName}`);
  }
});

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    // Accept common code file types
    const allowedTypes = [
      'text/plain',
      'text/javascript',
      'application/javascript',
      'text/x-python',
      'text/x-java-source',
      'text/x-c',
      'text/x-c++',
      'application/json',
      'text/xml',
      'application/xml'
    ];
    
    if (allowedTypes.includes(file.mimetype) || !file.mimetype) {
      cb(null, true);
    } else {
      cb(null, true); // Accept all files for now, let Semgrep handle compatibility
    }
  }
});

// Root route - handles Railway health checks
app.get('/', (req, res) => {
  res.status(200).json({ 
    status: 'success', 
    message: 'Cybersecurity Scanner API is running',
    version: '1.0.0',
    timestamp: new Date().toISOString()
  });
});

// Health check endpoint
app.get('/healthz', (req, res) => {
  res.status(200).json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString()
  });
});

// Catch-all GET route to prevent 404s from killing the container
app.get('*', (req, res) => {
  res.status(200).json({ 
    status: 'success', 
    message: 'API endpoint exists',
    path: req.path,
    timestamp: new Date().toISOString()
  });
});

// Scan endpoint
app.post('/scan', upload.single('file'), async (req, res) => {
  console.log('Scan request received');
  
  if (!req.file) {
    return res.status(400).json({ 
      status: 'error', 
      message: 'No file uploaded' 
    });
  }

  const filePath = req.file.path;
  console.log('File uploaded to:', filePath);

  try {
    // Run Semgrep scan
    const semgrepResults = await runSemgrepScan(filePath);
    
    // Clean up uploaded file
    fs.unlinkSync(filePath);
    
    res.json({
      status: 'success',
      filename: req.file.originalname,
      results: semgrepResults
    });
    
  } catch (error) {
    console.error('Scan error:', error);
    
    // Clean up uploaded file on error
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
    
    res.status(500).json({ 
      status: 'error', 
      message: 'Scan failed',
      error: error.message
    });
  }
});

// Function to run Semgrep scan
function runSemgrepScan(filePath) {
  return new Promise((resolve, reject) => {
    console.log('Starting Semgrep scan for:', filePath);
    
    const semgrepArgs = [
      '--json',
      '--config=auto',
      filePath
    ];
    
    const semgrepProcess = spawn('semgrep', semgrepArgs, {
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    let stdout = '';
    let stderr = '';
    
    semgrepProcess.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    
    semgrepProcess.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    semgrepProcess.on('close', (code) => {
      console.log('Semgrep process exited with code:', code);
      
      if (code === 0 || code === 1) {
        // Code 0 = no findings, Code 1 = findings found (both are success)
        try {
          const results = stdout ? JSON.parse(stdout) : { results: [] };
          resolve(results);
        } catch (parseError) {
          console.error('Failed to parse Semgrep output:', parseError);
          resolve({ 
            results: [], 
            raw_output: stdout,
            parse_error: parseError.message 
          });
        }
      } else {
        // Other exit codes indicate errors
        reject(new Error(`Semgrep failed with exit code ${code}: ${stderr}`));
      }
    });
    
    semgrepProcess.on('error', (error) => {
      console.error('Semgrep spawn error:', error);
      reject(error);
    });
  });
}

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error);
  res.status(500).json({ 
    status: 'error', 
    message: 'Internal server error' 
  });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`Allowed origins: ${process.env.ALLOWED_ORIGIN || 'not set'}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  process.exit(0);
});